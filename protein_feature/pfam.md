# pfam

## Pfam Object

### init
Goals:
* initialize all attributes

Input:
* db: sqlite database contains Pfam information generated by SpineD.

Output:
* none

Steps:
* assing db
* get logger

### query_pfam_info
Goals:
* create query_info from each record in pfam_infoif start and end are within bounds

Input:
* transcript_id
* pstart
* pend
* pfam_info

Output:
* query_info list

Steps:
* create empty query_info list
* loop through records in pfam_info
  * assign trans_id, start, end, family, name, clan from record
  > trans_id, family, name, clan are unused. could be swapped to _ to ignore
  * if start and end are within bound of pstart and pend
    * append record to query_info
* return query_info

### cal_pfam
Goals:
* 

Input:
* transcript_if
* pstart
* pend

Output:
* pfam: float

Steps:
* get pfam_info from self.db.query_pfam()
* initialize pfam as 'NA'
* if pstart and pend
  * if pfam_info
    * get query_result from self.query_pfam_info()
    * if query_result
      * set pfam to 0.0
      * reassign query_result using self._merge_interval()
      * loop through query_result with start, end as sentries
        * pfam += (min(pend, end) - max(pstart, start))
      * assert pfam <= (pend - pstart + 1)
      * pfam /= (pend - pstart + 1)
    * else
      * pfam = 0.0
      * log debug 'region does not contain pfam'
  * else
    * pfam = 0.0
* return pfam

### _merge_interval
Goals:
* merge intervals and return

Input:
* intervals

Output:
* merged intervals

Steps:
* create intervals list using [[x[1], x[2]] for x in intervals] as the starting values
* create empty list called result
* append element 0 of intervals to result
* loop through elements 1:end of intervals
  * if intervals[i][1] > result[-1][1]
    * append intervals[i][1] to result
  * else
    * result[-1][1] = max(result[-1][1], intervals[i][1])
* return result